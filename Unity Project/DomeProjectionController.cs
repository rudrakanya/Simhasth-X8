# Dome Projection Controller
# Manages content for immersive dome theater experiences

using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using System.Collections;
using System.Collections.Generic;

namespace HeritageDigitalTwins.Dome
{
    /// <summary>
    /// Controls dome projection setup for group heritage experiences
    /// Supports fulldome projection mapping and multi-projector systems
    /// </summary>
    public class DomeProjectionController : MonoBehaviour
    {
        [Header("Dome Configuration")]
        public DomeType domeType = DomeType.Geodesic;
        public float domeRadius = 6f; // meters
        public int projectorCount = 6;
        public float projectorFOV = 90f;
        
        [Header("Cameras")]
        public Camera[] projectorCameras;
        public Camera masterCamera;
        public Transform domeCenter;
        
        [Header("Render Textures")]
        public RenderTexture[] projectorTextures;
        public int textureResolution = 2048;
        
        [Header("Heritage Content")]
        public HeritageTourSequence tourSequence;
        public Transform virtualTourPath;
        public float tourSpeed = 2f;
        
        [Header("Cultural Effects")]
        public ParticleSystem[] ambientParticles;
        public Light[] dynamicLighting;
        public AudioSource spatialAudio;
        
        // Private variables
        private bool isDomeActive = false;\n        private float currentTourProgress = 0f;\n        private Coroutine tourCoroutine;\n        private HeritageAudioManager audioManager;\n        \n        public enum DomeType\n        {\n            Geodesic,\n            Inflatable,\n            CAVE,\n            Custom\n        }\n        \n        private void Start()\n        {\n            InitializeDomeProjection();\n        }\n        \n        private void InitializeDomeProjection()\n        {\n            audioManager = FindObjectOfType<HeritageAudioManager>();\n            \n            // Setup projector cameras based on dome configuration\n            SetupProjectorCameras();\n            \n            // Initialize render textures\n            InitializeRenderTextures();\n            \n            // Configure dome-specific settings\n            ConfigureDomeSettings();\n            \n            Debug.Log($\"Dome projection initialized: {domeType} with {projectorCount} projectors\");\n        }\n        \n        private void SetupProjectorCameras()\n        {\n            if (projectorCameras == null || projectorCameras.Length != projectorCount)\n            {\n                projectorCameras = new Camera[projectorCount];\n            }\n            \n            for (int i = 0; i < projectorCount; i++)\n            {\n                if (projectorCameras[i] == null)\n                {\n                    // Create projector camera\n                    GameObject cameraObj = new GameObject($\"ProjectorCamera_{i}\");\n                    cameraObj.transform.SetParent(domeCenter);\n                    projectorCameras[i] = cameraObj.AddComponent<Camera>();\n                }\n                \n                Camera cam = projectorCameras[i];\n                \n                // Position cameras around dome\n                float angle = (360f / projectorCount) * i;\n                Vector3 position = new Vector3(\n                    Mathf.Sin(Mathf.Deg2Rad * angle) * domeRadius * 0.8f,\n                    domeRadius * 0.3f,\n                    Mathf.Cos(Mathf.Deg2Rad * angle) * domeRadius * 0.8f\n                );\n                \n                cam.transform.localPosition = position;\n                cam.transform.LookAt(domeCenter);\n                \n                // Configure camera settings for dome projection\n                cam.fieldOfView = projectorFOV;\n                cam.nearClipPlane = 0.1f;\n                cam.farClipPlane = 100f;\n                cam.cullingMask = LayerMask.GetMask(\"Heritage\", \"Default\");\n                \n                // Assign render texture\n                cam.targetTexture = projectorTextures[i];\n            }\n        }\n        \n        private void InitializeRenderTextures()\n        {\n            if (projectorTextures == null || projectorTextures.Length != projectorCount)\n            {\n                projectorTextures = new RenderTexture[projectorCount];\n            }\n            \n            for (int i = 0; i < projectorCount; i++)\n            {\n                if (projectorTextures[i] == null)\n                {\n                    projectorTextures[i] = new RenderTexture(textureResolution, textureResolution, 24);\n                    projectorTextures[i].name = $\"ProjectorTexture_{i}\";\n                }\n            }\n        }\n        \n        private void ConfigureDomeSettings()\n        {\n            switch (domeType)\n            {\n                case DomeType.Geodesic:\n                    ConfigureGeodesicDome();\n                    break;\n                case DomeType.Inflatable:\n                    ConfigureInflatableDome();\n                    break;\n                case DomeType.CAVE:\n                    ConfigureCAVESystem();\n                    break;\n                case DomeType.Custom:\n                    ConfigureCustomDome();\n                    break;\n            }\n        }\n        \n        private void ConfigureGeodesicDome()\n        {\n            // Geodesic dome specific configuration\n            projectorFOV = 100f; // Wider FOV for geodesic projection\n            \n            // Adjust camera positions for geodesic geometry\n            for (int i = 0; i < projectorCameras.Length; i++)\n            {\n                if (projectorCameras[i] != null)\n                {\n                    projectorCameras[i].fieldOfView = projectorFOV;\n                }\n            }\n        }\n        \n        private void ConfigureInflatableDome()\n        {\n            // Inflatable dome configuration (portable setup)\n            projectorFOV = 85f;\n            \n            // Adjust for typically smaller inflatable domes\n            domeRadius = Mathf.Min(domeRadius, 4f);\n        }\n        \n        private void ConfigureCAVESystem()\n        {\n            // CAVE system uses flat projection walls\n            projectorCount = Mathf.Min(projectorCount, 4); // Typically 3-4 walls\n            projectorFOV = 90f;\n            \n            // Reconfigure cameras for flat wall projection\n            for (int i = 0; i < projectorCount; i++)\n            {\n                if (projectorCameras[i] != null)\n                {\n                    // Position cameras for wall projection\n                    float angle = 90f * i; // 90-degree intervals for walls\n                    Vector3 wallPosition = new Vector3(\n                        Mathf.Sin(Mathf.Deg2Rad * angle) * domeRadius,\n                        0f,\n                        Mathf.Cos(Mathf.Deg2Rad * angle) * domeRadius\n                    );\n                    \n                    projectorCameras[i].transform.localPosition = wallPosition;\n                    projectorCameras[i].transform.LookAt(domeCenter);\n                }\n            }\n        }\n        \n        private void ConfigureCustomDome()\n        {\n            // Custom dome configuration - can be extended\n            Debug.Log(\"Custom dome configuration - implement specific requirements\");\n        }\n        \n        public void StartHeritageTour()\n        {\n            if (isDomeActive) return;\n            \n            isDomeActive = true;\n            \n            // Activate all projector cameras\n            foreach (Camera cam in projectorCameras)\n            {\n                if (cam != null)\n                    cam.enabled = true;\n            }\n            \n            // Start heritage tour sequence\n            if (tourSequence != null)\n            {\n                tourCoroutine = StartCoroutine(ExecuteHeritageTour());\n            }\n            \n            Debug.Log(\"Heritage dome tour started\");\n        }\n        \n        public void StopHeritageTour()\n        {\n            if (!isDomeActive) return;\n            \n            isDomeActive = false;\n            \n            // Stop tour coroutine\n            if (tourCoroutine != null)\n            {\n                StopCoroutine(tourCoroutine);\n                tourCoroutine = null;\n            }\n            \n            // Deactivate projector cameras\n            foreach (Camera cam in projectorCameras)\n            {\n                if (cam != null)\n                    cam.enabled = false;\n            }\n            \n            currentTourProgress = 0f;\n            \n            Debug.Log(\"Heritage dome tour stopped\");\n        }\n        \n        private IEnumerator ExecuteHeritageTour()\n        {\n            if (tourSequence == null || virtualTourPath == null) yield break;\n            \n            HeritageTourPoint[] tourPoints = tourSequence.tourPoints;\n            \n            for (int i = 0; i < tourPoints.Length; i++)\n            {\n                HeritageTourPoint point = tourPoints[i];\n                \n                // Move all cameras to tour point\n                yield return StartCoroutine(MoveCamerasToTourPoint(point));\n                \n                // Play cultural narration for this point\n                if (point.narrationClip != null && audioManager != null)\n                {\n                    audioManager.PlayCulturalNarration(point.narrationClip);\n                    yield return new WaitForSeconds(point.narrationClip.length);\n                }\n                \n                // Apply environmental effects\n                ApplyEnvironmentalEffects(point);\n                \n                // Wait at this point\n                yield return new WaitForSeconds(point.waitDuration);\n                \n                currentTourProgress = (float)(i + 1) / tourPoints.Length;\n            }\n            \n            // Tour completed\n            OnTourCompleted();\n        }\n        \n        private IEnumerator MoveCamerasToTourPoint(HeritageTourPoint point)\n        {\n            Vector3[] startPositions = new Vector3[projectorCameras.Length];\n            Quaternion[] startRotations = new Quaternion[projectorCameras.Length];\n            \n            // Record starting positions\n            for (int i = 0; i < projectorCameras.Length; i++)\n            {\n                if (projectorCameras[i] != null)\n                {\n                    startPositions[i] = projectorCameras[i].transform.position;\n                    startRotations[i] = projectorCameras[i].transform.rotation;\n                }\n            }\n            \n            float moveDuration = point.transitionDuration;\n            float timer = 0f;\n            \n            while (timer < moveDuration)\n            {\n                float progress = timer / moveDuration;\n                float easedProgress = Mathf.SmoothStep(0f, 1f, progress);\n                \n                // Move each camera\n                for (int i = 0; i < projectorCameras.Length; i++)\n                {\n                    if (projectorCameras[i] != null)\n                    {\n                        // Calculate target position relative to tour point\n                        Vector3 targetPos = point.cameraPosition + GetProjectorOffset(i);\n                        Quaternion targetRot = Quaternion.LookRotation(\n                            point.lookDirection, Vector3.up\n                        );\n                        \n                        projectorCameras[i].transform.position = Vector3.Lerp(\n                            startPositions[i], targetPos, easedProgress\n                        );\n                        projectorCameras[i].transform.rotation = Quaternion.Slerp(\n                            startRotations[i], targetRot, easedProgress\n                        );\n                    }\n                }\n                \n                timer += Time.deltaTime;\n                yield return null;\n            }\n        }\n        \n        private Vector3 GetProjectorOffset(int projectorIndex)\n        {\n            // Calculate offset for each projector to maintain dome coverage\n            float angle = (360f / projectorCount) * projectorIndex;\n            return new Vector3(\n                Mathf.Sin(Mathf.Deg2Rad * angle) * 0.5f,\n                0f,\n                Mathf.Cos(Mathf.Deg2Rad * angle) * 0.5f\n            );\n        }\n        \n        private void ApplyEnvironmentalEffects(HeritageTourPoint point)\n        {\n            // Apply lighting changes\n            if (point.lightingSetup != null)\n            {\n                ApplyLightingSetup(point.lightingSetup);\n            }\n            \n            // Trigger particle effects\n            if (point.particleEffects != null)\n            {\n                TriggerParticleEffects(point.particleEffects);\n            }\n            \n            // Apply post-processing effects\n            if (point.postProcessingProfile != null)\n            {\n                ApplyPostProcessing(point.postProcessingProfile);\n            }\n        }\n        \n        private void ApplyLightingSetup(DomeLightingSetup lighting)\n        {\n            // Adjust lighting for cultural atmosphere\n            for (int i = 0; i < dynamicLighting.Length && i < lighting.lightSettings.Length; i++)\n            {\n                Light light = dynamicLighting[i];\n                LightSetting setting = lighting.lightSettings[i];\n                \n                StartCoroutine(AnimateLightTransition(light, setting));\n            }\n        }\n        \n        private IEnumerator AnimateLightTransition(Light light, LightSetting targetSetting)\n        {\n            Color startColor = light.color;\n            float startIntensity = light.intensity;\n            \n            float duration = 2f;\n            float timer = 0f;\n            \n            while (timer < duration)\n            {\n                float progress = timer / duration;\n                \n                light.color = Color.Lerp(startColor, targetSetting.color, progress);\n                light.intensity = Mathf.Lerp(startIntensity, targetSetting.intensity, progress);\n                \n                timer += Time.deltaTime;\n                yield return null;\n            }\n            \n            light.color = targetSetting.color;\n            light.intensity = targetSetting.intensity;\n        }\n        \n        private void TriggerParticleEffects(ParticleEffectSetup[] effects)\n        {\n            foreach (var effect in effects)\n            {\n                if (effect.particleSystem != null)\n                {\n                    var main = effect.particleSystem.main;\n                    main.startColor = effect.color;\n                    main.startLifetime = effect.lifetime;\n                    \n                    effect.particleSystem.Play();\n                }\n            }\n        }\n        \n        private void ApplyPostProcessing(VolumeProfile profile)\n        {\n            // Apply post-processing for cinematic heritage presentation\n            Volume volume = FindObjectOfType<Volume>();\n            if (volume != null)\n            {\n                volume.profile = profile;\n            }\n        }\n        \n        private void OnTourCompleted()\n        {\n            Debug.Log(\"Heritage dome tour completed\");\n            \n            // Reset to starting position\n            currentTourProgress = 0f;\n            \n            // Play completion audio\n            if (audioManager != null)\n            {\n                audioManager.PlayTourCompletionAudio();\n            }\n            \n            // Option to restart or return to menu\n            // This would trigger UI for tour options\n        }\n        \n        public void SetTourSpeed(float speed)\n        {\n            tourSpeed = Mathf.Clamp(speed, 0.1f, 5f);\n        }\n        \n        public void JumpToTourPoint(int pointIndex)\n        {\n            if (tourSequence == null || pointIndex >= tourSequence.tourPoints.Length)\n                return;\n                \n            // Stop current tour\n            if (tourCoroutine != null)\n            {\n                StopCoroutine(tourCoroutine);\n            }\n            \n            // Jump to specific point\n            HeritageTourPoint point = tourSequence.tourPoints[pointIndex];\n            StartCoroutine(MoveCamerasToTourPoint(point));\n            \n            currentTourProgress = (float)pointIndex / tourSequence.tourPoints.Length;\n        }\n        \n        public void PauseTour()\n        {\n            if (tourCoroutine != null)\n            {\n                StopCoroutine(tourCoroutine);\n                tourCoroutine = null;\n            }\n        }\n        \n        public void ResumeTour()\n        {\n            if (isDomeActive && tourCoroutine == null)\n            {\n                tourCoroutine = StartCoroutine(ExecuteHeritageTour());\n            }\n        }\n        \n        public void EnableProjector(int projectorIndex, bool enable)\n        {\n            if (projectorIndex >= 0 && projectorIndex < projectorCameras.Length)\n            {\n                if (projectorCameras[projectorIndex] != null)\n                {\n                    projectorCameras[projectorIndex].enabled = enable;\n                }\n            }\n        }\n        \n        // MSME Training: Simplified dome control interface\n        public void MSMEStartBasicTour()\n        {\n            // Simplified tour start for MSME operators\n            StartHeritageTour();\n        }\n        \n        public void MSMEStopTour()\n        {\n            // Simplified tour stop\n            StopHeritageTour();\n        }\n        \n        public float GetTourProgress()\n        {\n            return currentTourProgress;\n        }\n        \n        private void OnValidate()\n        {\n            // Ensure projector count is reasonable\n            projectorCount = Mathf.Clamp(projectorCount, 1, 12);\n            \n            // Ensure dome radius is reasonable\n            domeRadius = Mathf.Clamp(domeRadius, 2f, 20f);\n        }\n        \n        private void OnDisable()\n        {\n            StopHeritageTour();\n        }\n    }\n    \n    [System.Serializable]\n    public class HeritageTourPoint\n    {\n        public string pointName;\n        public Vector3 cameraPosition;\n        public Vector3 lookDirection;\n        public float waitDuration = 3f;\n        public float transitionDuration = 2f;\n        public AudioClip narrationClip;\n        public DomeLightingSetup lightingSetup;\n        public ParticleEffectSetup[] particleEffects;\n        public VolumeProfile postProcessingProfile;\n    }\n    \n    [System.Serializable]\n    public class DomeLightingSetup\n    {\n        public LightSetting[] lightSettings;\n        public Color ambientColor = Color.white;\n        public float ambientIntensity = 0.2f;\n    }\n    \n    [System.Serializable]\n    public class LightSetting\n    {\n        public Color color = Color.white;\n        public float intensity = 1f;\n        public Vector3 direction = Vector3.down;\n    }\n    \n    [System.Serializable]\n    public class ParticleEffectSetup\n    {\n        public ParticleSystem particleSystem;\n        public Color color = Color.white;\n        public float lifetime = 2f;\n        public bool autoTrigger = true;\n    }\n}